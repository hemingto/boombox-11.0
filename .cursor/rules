# Boombox 11.0 - Cursor AI Rules

## üö® QUICK REFERENCE: Always Work in boombox-11.0
**BEFORE ANY FILE CREATION**: Run `pwd` ‚Üí Should show `/Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`
**IF NOT**: Run `cd /Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`
**NEVER CREATE FILES IN**: `boombox-workspace/src/` (workspace level) ‚ùå
**ALWAYS CREATE FILES IN**: `boombox-11.0/src/` (project level) ‚úÖ

## Project Context
This is a Next.js 15+ application using TypeScript, Tailwind CSS, Prisma ORM with PostgreSQL, and deployed on Vercel. We are refactoring from boombox-10.0 to create a clean, modern codebase structure.

## Key Integrations (DO NOT CHANGE FUNCTIONALITY)
- **Onfleet API v2.7**: Logistics and delivery management - preserve exact functionality
- **Stripe Connect**: Payment processing - preserve exact functionality  
- **Prisma**: Database ORM with PostgreSQL (Neon)
- **NextAuth.js**: Authentication system
- **Twilio**: SMS messaging
- **SendGrid**: Email messaging

## CRITICAL: Workspace Directory Structure

### üö® WORKSPACE LAYOUT OVERVIEW
```
/Users/calvinhemington/Desktop/boombox-workspace/
‚îú‚îÄ‚îÄ boombox-10.0/                    # ‚ùå OLD VERSION - READ ONLY
‚îÇ   ‚îú‚îÄ‚îÄ src/                         # Source code to copy FROM
‚îÇ   ‚îú‚îÄ‚îÄ docs/                        # Reference documentation
‚îÇ   ‚îî‚îÄ‚îÄ ...                          # Legacy files
‚îú‚îÄ‚îÄ boombox-11.0/                    # ‚úÖ NEW VERSION - ACTIVE PROJECT
‚îÇ   ‚îú‚îÄ‚îÄ src/                         # üéØ TARGET: All new files go HERE
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app/                     # Next.js App Router
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/              # React components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/                     # Utilities & services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/                   # TypeScript definitions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...                      # Other source directories
‚îÇ   ‚îú‚îÄ‚îÄ docs/                        # New documentation
‚îÇ   ‚îú‚îÄ‚îÄ .cursor/                     # This rules file
‚îÇ   ‚îî‚îÄ‚îÄ ...                          # Project configuration
‚îî‚îÄ‚îÄ [OTHER DIRECTORIES]              # ‚ùå NEVER CREATE FILES HERE
```

### üéØ CORRECT FILE CREATION LOCATIONS
**ALWAYS CREATE FILES IN**: `/Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0/`

**EXAMPLES OF CORRECT PATHS**:
- ‚úÖ `boombox-11.0/src/types/api.types.ts`
- ‚úÖ `boombox-11.0/src/lib/validations/api.validations.ts`
- ‚úÖ `boombox-11.0/src/components/ui/Button.tsx`
- ‚úÖ `boombox-11.0/docs/api/endpoint-docs.md`

**EXAMPLES OF WRONG PATHS** (NEVER CREATE):
- ‚ùå `boombox-workspace/src/types/api.types.ts` (missing boombox-11.0)
- ‚ùå `src/types/api.types.ts` (when pwd is boombox-workspace)
- ‚ùå `../src/types/api.types.ts` (relative path confusion)
- ‚ùå `boombox-10.0/src/anything.ts` (read-only directory)

### üîç DIRECTORY IDENTIFICATION CHECKLIST
**Before creating ANY file, verify**:
1. Run `pwd` - should show `/Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`
2. If not in boombox-11.0, navigate: `cd /Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`
3. Confirm with `ls` - should see: `src/`, `docs/`, `.cursor/`, `package.json`, etc.
4. ONLY THEN create files using relative paths like `src/types/filename.ts`

### ‚ö†Ô∏è DANGER SIGNALS
**STOP IMMEDIATELY if you see**:
- Creating files in `boombox-workspace/src/` (workspace level)
- Any path containing `../` during file creation
- Working directory showing `boombox-workspace` instead of `boombox-11.0`
- Files appearing outside the boombox-11.0 directory structure

## File Structure Rules

### Component Organization (STRICT)
- ALL React components must be in `src/components/` directory
- NEVER put components in `src/app/components/`
- Organize by category:
  - `src/components/ui/` - Reusable design system components
  - `src/components/layouts/` - Layout components
  - `src/components/forms/` - Form components
  - `src/components/features/` - Business domain components
  - `src/components/icons/` - Icon components

### App Directory Rules (STRICT)
- `src/app/` should ONLY contain:
  - Route pages (`page.tsx`)
  - Route layouts (`layout.tsx`) 
  - Loading states (`loading.tsx`)
  - Error boundaries (`error.tsx`)
  - API routes (`route.ts`)
  - Route groups: `(auth)`, `(dashboard)`, `(public)`

### Routing Rules (CRITICAL - Performance & UX)
**NEVER use client-side redirects with router.replace() or router.push() for navigation logic**

#### Prohibited Patterns (from boombox-10.0)
```typescript
// ‚ùå BAD: Loading component just to redirect
export default function TaskPage() {
  useEffect(() => {
    if (taskId.startsWith('storage-')) {
      router.replace(`/admin/tasks/${taskId}/assign-storage-unit`);
    }
    // ... more string parsing logic
  }, []);
  return null; // Component loads just to redirect!
}
```

#### Required Patterns (Next.js Best Practices)
```typescript
// ‚úÖ GOOD: Direct route structure
/admin/tasks/
‚îú‚îÄ‚îÄ page.tsx                      # Task list
‚îú‚îÄ‚îÄ storage/[taskId]/page.tsx     # Direct route - no redirects
‚îú‚îÄ‚îÄ feedback/[taskId]/page.tsx    # Direct route - no redirects
‚îú‚îÄ‚îÄ cleaning/[taskId]/page.tsx    # Direct route - no redirects
‚îî‚îÄ‚îÄ access/[taskId]/page.tsx      # Direct route - no redirects

// ‚úÖ GOOD: Direct URL generation
const taskUrl = `/admin/tasks/${taskType}/${taskId}`;
return <Link href={taskUrl}>View Task</Link>;
```

#### Route Group Organization
- Use route groups for logical organization: `(dashboard)`, `(auth)`, `(public)`
- Implement proper layout hierarchies with shared components
- Add route-level authorization and role checking in layouts
- Create breadcrumb navigation for deep hierarchies

#### Navigation Patterns
- **Links**: Use Next.js `<Link>` component for navigation
- **Forms**: Use form actions and redirects in Server Actions
- **Programmatic**: Only use `router.push()` for user-triggered actions (form submissions, button clicks)
- **Never**: Load components just to parse URLs and redirect

#### URL Structure Standards
- Use descriptive, hierarchical URLs: `/admin/tasks/storage/storage-123`
- Implement proper route parameters: `[taskId]`, `[category]`, `[slug]`
- Support deep-linking to all application states
- Maintain backward compatibility for bookmarked URLs

#### Performance Requirements
- Eliminate unnecessary component mounting/unmounting from redirects
- Use proper Next.js static optimization where possible
- Implement loading states at the route level (`loading.tsx`)
- Add error boundaries at appropriate route levels (`error.tsx`)

### Import Path Rules (STRICT)
- ALWAYS use absolute imports with `@/` prefix
- Examples:
  - `import { Button } from '@/components/ui/Button'`
  - `import { MessageService } from '@/lib/messaging/MessageService'`
  - `import { ApiResponse } from '@/types/api'`
- NEVER use relative imports like `../../../`

## Naming Conventions (STRICT)

### File Naming Standards
- **Components**: PascalCase with domain prefix (`UserAuthForm.tsx`, `OnfleetTaskCard.tsx`)
- **Pages**: Always `page.tsx`, `layout.tsx`, `loading.tsx`, `error.tsx` (Next.js standard)
- **API Routes**: Always `route.ts` in kebab-case directories
- **Services/Utils**: camelCase with domain (`onfleetApiClient.ts`, `stripePaymentService.ts`)
- **Types**: Domain-based (`onfleet.types.ts`, `booking.types.ts`)

### File Source Documentation (REQUIRED)
Every refactored file must include source mapping:
```typescript
/**
 * @fileoverview Component description
 * @source boombox-10.0/path/to/original/file.tsx
 * @source boombox-10.0/path/to/another/file.tsx (if consolidated)
 * @refactor Reason for change/consolidation
 */
```

### Functional Naming Principles
1. **Descriptive over Generic**: `OnfleetTaskStatus` vs `TaskStatus`
2. **Domain Prefix**: Include business domain (`StripePaymentForm`)
3. **Action-Oriented**: `CreateBookingForm` vs `BookingForm`
4. **Consistent Suffixes**: `Service`, `Utils`, `Types`, `Client`
5. **No Abbreviations**: `customer` not `cust`, `appointment` not `appt`

## Coding Standards

### Component Patterns
- Use function declarations: `export function ComponentName() {}`
- Always type component props with interfaces
- Include `className?: string` prop for Tailwind customization
- Use consistent prop patterns with variants and sizes

### Design System Integration (CRITICAL)
**MANDATORY**: During component migration, ALWAYS leverage the centralized design system:

#### Tailwind Config Color Variables (REQUIRED)
**NEVER use hardcoded colors** - Always use semantic color tokens from `tailwind.config.ts`:

**‚úÖ CORRECT - Use semantic colors:**
```typescript
// Error states
'text-status-error'        // Instead of 'text-red-500'
'bg-status-bg-error'       // Instead of 'bg-red-100'
'border-border-error'      // Instead of 'border-red-500'

// Text hierarchy
'text-text-primary'        // Instead of 'text-zinc-950'
'text-text-secondary'      // Instead of 'text-zinc-400'
'text-text-tertiary'       // Instead of 'text-zinc-600'

// Surface colors
'bg-surface-primary'       // Instead of 'bg-white'
'bg-surface-tertiary'      // Instead of 'bg-slate-100'
'bg-surface-disabled'      // Instead of 'bg-slate-200'

// Brand colors
'bg-primary'               // Instead of 'bg-zinc-950'
'hover:bg-primary-hover'   // Instead of 'hover:bg-zinc-800'
```

**‚ùå WRONG - Hardcoded colors:**
```typescript
'text-red-500'             // Use 'text-status-error'
'text-zinc-950'            // Use 'text-text-primary'
'bg-slate-100'             // Use 'bg-surface-tertiary'
'border-red-500'           // Use 'border-border-error'
```

#### Global CSS Classes (REQUIRED)
**ALWAYS use existing CSS classes** from `globals.css` instead of recreating styles:

**‚úÖ CORRECT - Use global classes:**
```typescript
// Form components
'form-group'               // Container spacing
'form-label'               // Label styling
'form-error'               // Error message styling
'form-helper'              // Helper text styling
'input-field'              // Base input styling
'input-field--error'       // Error state styling

// Buttons
'btn-primary'              // Primary button
'btn-secondary'            // Secondary button
'btn-destructive'          // Destructive action button

// Cards and layout
'card'                     // Standard card styling
'page-container'           // Page width container
'section-spacing'          // Consistent section padding

// Status indicators
'badge-success'            // Success badge
'badge-error'              // Error badge
'badge-warning'            // Warning badge
```

**‚ùå WRONG - Recreating existing styles:**
```typescript
// Don't recreate form styling
'block text-lg font-normal text-primary mb-4'  // Use 'form-label'
'text-sm text-red-500 mt-1'                    // Use 'form-error'
'px-6 py-2.5 bg-zinc-950 text-white rounded'   // Use 'btn-primary'
```

#### Migration Checklist (MANDATORY)
**Before completing ANY component migration:**

1. **Color Audit**: Search component for ALL hardcoded colors:
   - `text-red-*`, `text-zinc-*`, `text-gray-*` ‚Üí Use semantic tokens
   - `bg-red-*`, `bg-slate-*`, `bg-gray-*` ‚Üí Use surface/status colors
   - `border-red-*`, `border-gray-*` ‚Üí Use border tokens

2. **Class Consolidation**: Replace custom Tailwind combinations:
   - Form styling ‚Üí Use `form-*` classes
   - Button styling ‚Üí Use `btn-*` classes
   - Card styling ‚Üí Use `card` classes
   - Badge styling ‚Üí Use `badge-*` classes

3. **Design System Verification**: Ensure component uses:
   - ‚úÖ Semantic color names (not specific color values)
   - ‚úÖ Global CSS classes where applicable
   - ‚úÖ Consistent spacing from design system
   - ‚úÖ Typography scale from config

4. **Documentation**: Add comment explaining design system usage:
   ```typescript
   /**
    * @design-system Uses semantic colors and global form classes
    * @colors text-status-error, bg-surface-tertiary, border-border-error
    * @classes form-group, form-label, input-field, input-field--error
    */
   ```

#### Common Migration Patterns
```typescript
// ‚ùå BEFORE: boombox-10.0 style
<input className="w-full px-3 py-2 border border-gray-300 text-gray-900 placeholder-gray-500 focus:ring-blue-500" />
<span className="text-red-500 text-sm mt-1">{error}</span>

// ‚úÖ AFTER: boombox-11.0 with design system
<input className="input-field" />
<span className="form-error">{error}</span>
```

#### Design System Benefits
- **Consistency**: All components use the same color palette
- **Maintainability**: Color changes happen in one place (tailwind.config.ts)
- **Accessibility**: Centralized contrast ratio management
- **Performance**: Reduced CSS bundle size from class reuse
- **Developer Experience**: Semantic naming makes code self-documenting

### SEO, Accessibility & Performance (CRITICAL)
**All refactored code must be optimized for:**

#### SEO Requirements
- Include proper HTML semantics (`<main>`, `<nav>`, `<section>`, `<article>`)
- Add descriptive page titles and meta descriptions
- Use Next.js `Metadata` API for dynamic meta tags
- Implement structured data (JSON-LD) where applicable
- Ensure proper heading hierarchy (h1 ‚Üí h2 ‚Üí h3)
- Add alt text to all images with meaningful descriptions
- Use semantic HTML elements over generic divs

#### Accessibility Requirements (WCAG 2.1 AA)
- Include proper ARIA labels and roles
- Ensure keyboard navigation works for all interactive elements
- Maintain color contrast ratios ‚â• 4.5:1 for text
- Add focus indicators for keyboard users
- Use proper form labels and error messages
- Ensure screen reader compatibility
- Test with browser accessibility tools

#### Performance Optimization (Core Web Vitals)
- Use Next.js `Image` component with proper sizing and lazy loading
- Implement dynamic imports for heavy components: `const Heavy = dynamic(() => import('./Heavy'))`
- Minimize bundle size with tree-shaking and code splitting
- Use `loading="lazy"` for images below the fold
- Optimize fonts with `next/font` for better CLS scores
- Minimize layout shifts with proper size reservations
- Target metrics: LCP < 2.5s, FID < 100ms, CLS < 0.1

#### Image Optimization Pattern (MANDATORY)
**ALWAYS replace `bg-slate-*` placeholder divs with OptimizedImage component**

**‚ùå BAD - Placeholder div (boombox-10.0 pattern):**
```tsx
<div className="bg-slate-100 aspect-square w-full rounded-md"></div>
```

**‚úÖ GOOD - OptimizedImage component (boombox-11.0 pattern):**
```tsx
import { OptimizedImage } from '@/components/ui/primitives/OptimizedImage/OptimizedImage';

<OptimizedImage
  src="/img/feature-image.jpg"
  alt="Descriptive alt text for SEO and accessibility"
  width={500}
  height={500}
  aspectRatio="square"
  containerClassName="w-full rounded-md"
  className="object-cover rounded-md"
  loading="lazy"
  sizes="(max-width: 768px) 100vw, 50vw"
/>
```

**OptimizedImage Benefits:**
- ‚úÖ Automatic Next.js image optimization
- ‚úÖ Lazy loading with skeleton state
- ‚úÖ Proper SEO with alt text and img tags
- ‚úÖ Responsive sizing
- ‚úÖ Error handling with fallback support
- ‚úÖ Better accessibility than div with role="img"

**Common Patterns:**
```tsx
// Hero images - eager loading, high priority
<OptimizedImage
  src="/img/hero.jpg"
  alt="Hero description"
  width={1200}
  height={600}
  aspectRatio="wide"
  loading="eager"
  priority
  quality={90}
/>

// Content images - lazy loading, standard quality
<OptimizedImage
  src="/img/content.jpg"
  alt="Content description"
  width={800}
  height={600}
  aspectRatio="landscape"
  loading="lazy"
  quality={85}
/>

// Thumbnail/Card images - lazy, optimized for small size
<OptimizedImage
  src="/img/thumbnail.jpg"
  alt="Thumbnail description"
  width={400}
  height={400}
  aspectRatio="square"
  loading="lazy"
  quality={80}
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
/>
```

**Migration Checklist:**
- [ ] Identify all `bg-slate-*` or `bg-gray-*` divs that are image placeholders
- [ ] Replace with OptimizedImage component
- [ ] Add descriptive alt text (not just "image" or "placeholder")
- [ ] Set appropriate aspect ratio
- [ ] Configure lazy/eager loading based on position (above/below fold)
- [ ] Update tests to verify image rendering instead of div
- [ ] Remove old TODO comments about replacing placeholders

### API Route Patterns
- Use Zod for input validation
- Return consistent `ApiResponse<T>` format
- Implement proper error handling with try/catch
- Use appropriate HTTP status codes
- Follow user rule: NO `prisma db push` - use `prisma migrate dev`
- **Routing Structure**: Organize API routes by domain in clear directory hierarchies
  ```
  src/app/api/
  ‚îú‚îÄ‚îÄ auth/login/route.ts                    # /api/auth/login
  ‚îú‚îÄ‚îÄ payments/stripe-webhook/route.ts       # /api/payments/stripe-webhook
  ‚îú‚îÄ‚îÄ orders/create-appointment/route.ts     # /api/orders/create-appointment
  ‚îú‚îÄ‚îÄ onfleet/webhook/route.ts               # /api/onfleet/webhook
  ‚îú‚îÄ‚îÄ drivers/availability/route.ts          # /api/drivers/availability
  ‚îú‚îÄ‚îÄ moving-partners/assign/route.ts        # /api/moving-partners/assign
  ‚îú‚îÄ‚îÄ customers/profile/route.ts             # /api/customers/profile
  ‚îî‚îÄ‚îÄ admin/dashboard-stats/route.ts         # /api/admin/dashboard-stats
  ```
- **Route Documentation**: Include comprehensive route documentation comments (see REFACTOR_PRD.md template)
- **RESTful Patterns**: Use proper HTTP methods (GET, POST, PUT, DELETE) and status codes

### Type Safety
- All components must have proper TypeScript interfaces
- Use domain-specific type files in `src/types/`
- Create input/output type variants for database operations
- Always export types and interfaces

## Centralized Systems

### Messaging System
When working with Twilio/SendGrid messaging:
- Use centralized MessageService from `@/lib/messaging/MessageService`
- Store all message templates in `@/lib/messaging/templates/`
- Organize templates by domain: auth, booking, logistics, payment, admin
- Support multi-channel delivery (SMS + Email)
- Use variable substitution with `{{variableName}}` syntax

### Utility Function Consolidation (CRITICAL for Phase 5+)
**During component migration, ALWAYS extract utility functions to centralized utils:**

#### Detection Patterns
Look for these patterns in components that should be moved to `@/lib/utils/`:
- **Formatting functions**: `formatCurrency`, `formatDate`, `formatPhoneNumber`, `formatAddress`
- **Validation functions**: Email regex, phone validation, URL validation, form validation
- **Calculation functions**: Pricing calculations, capacity calculations, distance calculations
- **Parsing functions**: Address parsing, name parsing, data transformation
- **Helper functions**: Array manipulation, object utilities, string utilities
- **Business logic utilities**: Service area checks, availability calculations, pricing rules

#### Consolidation Process
1. **Identify**: Scan each component for utility functions (non-React, reusable logic)
2. **Extract**: Move functions to appropriate domain file in `@/lib/utils/`:
   - `phoneUtils.ts` - Phone formatting, validation, normalization
   - `dateUtils.ts` - Date formatting, parsing, calculations
   - `currencyUtils.ts` - Currency formatting, Stripe conversions
   - `validationUtils.ts` - Form validation, regex patterns
   - `formatUtils.ts` - General formatting, address parsing
   - `businessUtils.ts` - Business rules, capacity, pricing
   - `statusUtils.ts` - Status management, badge colors
   - **OR CREATE NEW FILE** if no existing domain fits (see "New Utility File Creation" below)
3. **Enhance**: Add proper TypeScript interfaces and documentation
4. **Update**: Replace component-level functions with imports from `@/lib/utils/`
5. **Test**: Ensure functionality remains identical

#### New Utility File Creation
**When existing utility files don't fit the new function's domain:**

##### Naming Convention
- **Format**: `{domain}Utils.ts` (camelCase + Utils suffix)
- **Examples**:
  - `imageUtils.ts` - Image processing, optimization, manipulation
  - `storageUtils.ts` - localStorage, sessionStorage, browser storage
  - `routingUtils.ts` - URL manipulation, route generation, navigation helpers
  - `analyticsUtils.ts` - Tracking, metrics, event logging
  - `fileUtils.ts` - File upload, download, processing
  - `mapUtils.ts` - Geographic calculations, coordinate transformations
  - `notificationUtils.ts` - Push notifications, alerts, toast management
  - `searchUtils.ts` - Search algorithms, filtering, sorting
  - `exportUtils.ts` - Data export, CSV generation, report formatting

##### File Structure Template
```typescript
/**
 * @fileoverview [Domain] utility functions for [specific purpose]
 * @source boombox-10.0/src/app/components/[component]/[file].tsx ([functionName])
 * @source boombox-10.0/src/app/[another-path]/[file].tsx ([functionName])
 * @refactor Consolidated [domain] utilities from multiple components
 */

// Types and interfaces
export interface [DomainName]Options {
  // ... interface definition
}

export interface [DomainName]Result {
  // ... interface definition
}

// Main utility functions
export function [primaryFunction](
  input: [InputType],
  options?: [DomainName]Options
): [DomainName]Result {
  // ... implementation
}

export function [secondaryFunction](
  // ... parameters
): [ReturnType] {
  // ... implementation
}

// Helper functions (not exported)
function [helperFunction](
  // ... parameters
): [ReturnType] {
  // ... implementation
}

// Constants
export const [DOMAIN_CONSTANTS] = {
  // ... constants
} as const;
```

##### Decision Matrix for New Files
**Create new utility file when:**
- ‚úÖ Function doesn't logically fit in existing 7 domain files
- ‚úÖ You find 2+ similar functions that would group together
- ‚úÖ The domain is distinct enough to warrant its own file
- ‚úÖ Functions are reusable across multiple components

**Add to existing file when:**
- ‚ùå Function is closely related to existing domain (e.g., phone formatting ‚Üí `phoneUtils.ts`)
- ‚ùå Only 1 function and unlikely to grow
- ‚ùå Function is a variation of existing utility (e.g., new date format ‚Üí `dateUtils.ts`)

##### Update Index.ts
**ALWAYS update `@/lib/utils/index.ts` when creating new utility files:**
```typescript
// Add to existing exports
export * from './newDomainUtils';
```

##### Documentation Requirements
- Include comprehensive JSDoc comments for all exported functions
- Add usage examples in comments
- Document any external dependencies
- Include performance considerations if applicable
- Add @since tag with version/date when function was added

##### Testing Considerations
- Add unit tests for new utility files in `tests/lib/utils/`
- Test edge cases and error conditions
- Validate TypeScript interfaces work correctly
- Ensure functions are pure (no side effects) when possible

#### Common Extraction Examples
```typescript
// ‚ùå BAD: Utility function in component
function CustomerDashboard() {
  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount);
  };
  // ... component logic
}

// ‚úÖ GOOD: Extract to utils
import { formatCurrency } from '@/lib/utils/currencyUtils';

function CustomerDashboard() {
  // ... component logic using formatCurrency()
}
```

#### Duplicate Function Priority
- **Phone normalization**: `normalizePhoneNumberToE164` (found in 5+ API routes)
- **Currency formatting**: `formatCurrency` variations (found in 4+ components)
- **Email validation**: Regex patterns (found in 6+ forms)
- **Date formatting**: Various date/time functions (found in 10+ components)
- **Address parsing**: Street address formatting (found in 3+ components)
- **Status colors**: Badge color logic (found in admin components)

#### Documentation Requirements
When extracting utilities, add source documentation:
```typescript
/**
 * @fileoverview Enhanced currency formatting utilities
 * @source boombox-10.0/src/app/components/dashboard/CustomerDashboard.tsx (formatCurrency)
 * @source boombox-10.0/src/app/components/admin/PayoutComponent.tsx (formatCurrency)
 * @refactor Consolidated duplicate currency formatting functions
 */
```

### Business Logic Preservation
- Maintain 99.9% functional compatibility with boombox-10.0
- Preserve ALL Onfleet integration logic exactly as-is
- Preserve ALL Stripe payment logic exactly as-is
- Only change code organization and structure, not business logic

## External API Guidelines

### Onfleet API Integration
- Current version: v2.7
- Base URL: `https://onfleet.com/api/v2/`
- **Full API Context**: See `docs/external-api-docs/onfleet-api-context.md` for complete integration patterns
- Key webhook events used:
  - Task Started (0): Customer notifications
  - Task ETA (1): 30-minute delivery notifications  
  - Task Completed (3): Order fulfillment
  - Task Failed (4): Exception handling
  - Worker Duty (5): Driver availability
  - Task Updated (7): Proof of delivery
  - Batch Job Completed (19): Route optimization

### Common Onfleet Patterns
- Always provide coordinates when available for better geocoding
- Use metadata for order tracking: `orderId`, `orderType`, `customerId`
- Implement proper webhook signature validation
- Use retry logic for failed API calls
- Test with Onfleet test environment

### Stripe Integration
- Preserve exact payment processing logic
- Maintain webhook endpoint functionality
- Keep subscription and payout systems unchanged
- Only update code organization, not payment flows

## File Creation Safety Rules

### üö® CRITICAL: edit_file Tool Path Requirements
**MANDATORY**: When using `edit_file`, ALWAYS use the FULL path including `boombox-11.0/` prefix:

**‚úÖ CORRECT edit_file paths:**
- `boombox-11.0/src/components/ui/Button.tsx`
- `boombox-11.0/src/lib/messaging/MessageService.ts`
- `boombox-11.0/src/types/api.types.ts`

**‚ùå WRONG edit_file paths (will create files outside boombox-11.0):**
- `src/components/ui/Button.tsx` (creates in workspace root)
- `src/lib/messaging/MessageService.ts` (creates in workspace root)
- `src/types/api.types.ts` (creates in workspace root)

**WHY**: The `edit_file` tool interprets relative paths relative to the WORKSPACE ROOT (`/Users/calvinhemington/Desktop/boombox-workspace/`) NOT the current working directory. This has caused multiple incidents where files were created outside boombox-11.0.

### CRITICAL: Always Stay Within boombox-11.0 Directory
- **REFERENCE**: See "CRITICAL: Workspace Directory Structure" section above for visual layout
- **NEVER create files outside the boombox-11.0 directory**
- **ALWAYS verify you're in `/Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`**
- **ALL file paths must be relative to boombox-11.0 root**
- **Before ANY file creation, MANDATORY: run `pwd` to confirm location**
- **If you accidentally create files outside boombox-11.0, immediately stop and fix**
- **LESSON LEARNED**: Previous incident created files in `boombox-workspace/src/` instead of `boombox-11.0/src/`

### MANDATORY Pre-File-Creation Checklist
**BEFORE creating ANY file, ALWAYS:**
1. **Run `pwd` command to verify current directory**
2. **Confirm you're in `/Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`**
3. **If not in boombox-11.0, navigate there with `cd /Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0`**
4. **ONLY THEN create files using relative paths**

### File Path Validation
- **CORRECT**: `src/components/` (relative to boombox-11.0 root)
- **WRONG**: `../src/components/` (parent directory reference)
- **CORRECT**: `src/lib/` (relative to boombox-11.0 root)  
- **WRONG**: `../src/lib/` (parent directory reference)
- All paths MUST start with `src/`, `docs/`, `tests/`, or `tools/`
- **ABSOLUTELY NEVER** use `../` when creating files in this project
- **DANGER ZONE**: If you see `boombox-workspace/src/` being created, STOP IMMEDIATELY

### Directory Structure Validation
**EXPECTED**: `/Users/calvinhemington/Desktop/boombox-workspace/boombox-11.0/src/`
**WRONG**: `/Users/calvinhemington/Desktop/boombox-workspace/src/`
**WRONG**: `/Users/calvinhemington/Desktop/src/`

### Emergency Recovery Protocol
If files are created in wrong location:
1. **STOP all file creation immediately**
2. **Identify all misplaced files**
3. **Copy files to correct location in boombox-11.0**
4. **Delete misplaced files**
5. **Verify with `pwd` before continuing**

## Development Workflow

### Task Execution
- Work in atomic 2-4 hour chunks following REFACTOR_PRD.md
- **CRITICAL**: Mark completed tasks in REFACTOR_PRD.md using checkboxes `- [x]`
- Add completion details with date, time taken, git commit, and notes
- Update phase progress trackers with visual progress bars
- Commit after each completed task
- Test functionality after each change
- Maintain git-based safety (no complex backup systems)

### Testing Requirements
- Run `pnpm run build` after changes
- Run `pnpm run lint` for code standards
- Test critical workflows manually
- Preserve existing functionality during refactor

### Jest Testing Strategy & Standards (CRITICAL - Learned from 97‚Üí0 test failures)

#### **Testing Philosophy: Resilient, Maintainable, Fast**
Our testing approach prioritizes **test stability during refactoring** while maintaining comprehensive coverage. Based on fixing 97 failing tests, we've identified patterns that prevent test breakage during component migrations.

---

### **1. Test Architecture Principles (MANDATORY)**

#### **A. Test What Users See, Not Implementation Details**
```typescript
// ‚ùå BAD: Testing implementation details (breaks during refactoring)
expect(component.state.isLoading).toBe(true);
expect(mockFunction).toHaveBeenCalledTimes(3);

// ‚úÖ GOOD: Testing user-visible behavior (survives refactoring)
expect(screen.getByRole('status')).toHaveTextContent('Loading...');
expect(screen.getByRole('button')).toBeDisabled();
```

#### **B. Accessibility-First Testing (Prevents 40% of failures)**
```typescript
// REQUIRED: Add to EVERY component test file
import { axe, toHaveNoViolations } from 'jest-axe';
import { testAccessibility } from '@/tests/utils/accessibility';
expect.extend(toHaveNoViolations);

// MANDATORY: Test accessibility in multiple states
describe('Accessibility', () => {
  it('has no accessibility violations', async () => {
    const renderResult = render(<Component />);
    await testAccessibility(renderResult);
  });

  it('maintains accessibility with error state', async () => {
    const renderResult = render(<Component error="Test error" />);
    await testAccessibility(renderResult);
    expect(screen.getByRole('alert')).toHaveTextContent('Test error');
  });
});
```

#### **C. Component Architecture Alignment (Prevents 30% of failures)**
```typescript
// CRITICAL: Test actual component behavior, not assumptions
// ‚ùå BAD: Assuming native HTML behavior
expect(select).toHaveValue('option1'); // Fails if custom dropdown

// ‚úÖ GOOD: Test actual implementation
expect(screen.getByRole('combobox')).toHaveTextContent('Option 1');
expect(screen.getByDisplayValue('option1')).toBeInTheDocument(); // For form submission
```

---

### **2. Mock Strategy (CRITICAL - Prevents "Element type is invalid" errors)**

#### **A. Import/Export Pattern Detection (MANDATORY before mocking)**
```bash
# ALWAYS verify export pattern before creating mocks
grep -n "export" src/components/path/ComponentName.tsx

# Common patterns:
# Named export: "export { ComponentName }" or "export function ComponentName"
# Default export: "export default ComponentName" or "export default function"
# Mixed exports: Both named and default in same file
```

#### **B. Correct Mock Patterns (CRITICAL)**
```typescript
// ‚úÖ CORRECT: Named export mocking
// For: export { ComponentName } from './ComponentName'
jest.mock('@/components/path/ComponentName', () => ({
  ComponentName: function MockComponentName(props: any) {
    return <div data-testid="mock-component-name">{props.children}</div>;
  }
}));

// ‚úÖ CORRECT: Default export mocking  
// For: export default ComponentName
jest.mock('@/components/path/ComponentName', () => {
  const MockComponentName = (props: any) => (
    <div data-testid="mock-component-name">{props.children}</div>
  );
  MockComponentName.displayName = 'MockComponentName';
  return {
    __esModule: true,
    default: MockComponentName
  };
});

// ‚úÖ CORRECT: Next.js Router mocking (CRITICAL for hooks)
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(() => ({
    push: jest.fn(),
    refresh: jest.fn(),
    back: jest.fn(),
    forward: jest.fn()
  })),
  useSearchParams: jest.fn(() => ({
    get: jest.fn(),
    toString: jest.fn(() => '')
  }))
}));

jest.mock('next-auth/react', () => ({
  useSession: jest.fn(() => ({
    data: { user: { id: 'test-user-id' } },
    status: 'authenticated'
  }))
}));
```

#### **C. Mock Validation Checklist (REQUIRED)**
**Before completing component tests with mocks:**
- [ ] Verified actual import statement in component under test
- [ ] Checked actual export pattern in mocked component file  
- [ ] Mock pattern matches export pattern exactly
- [ ] Added `displayName` for default export mocks (debugging)
- [ ] Used `__esModule: true` for default exports
- [ ] Tested that component renders without "Element type is invalid" error
- [ ] Mock provides all props that real component expects

---

### **3. Test Isolation & Setup (Prevents test interference)**

#### **A. Proper Test Cleanup (MANDATORY)**
```typescript
// REQUIRED: Add to every test file with mocks
beforeEach(() => {
  jest.clearAllMocks();
  // Reset any global state
  mockRouter.push.mockClear();
  mockFetch.mockReset();
});

afterEach(() => {
  jest.restoreAllMocks();
  // Clean up any side effects
});
```

#### **B. Test Environment Setup**
```typescript
// CRITICAL: Mock browser APIs that components use
// Already configured in jest.setup.js:
// - ResizeObserver, IntersectionObserver
// - window.matchMedia, window.scrollTo
// - localStorage, sessionStorage
// - Console method filtering

// ADD component-specific mocks as needed:
Object.defineProperty(window, 'HTMLElement', {
  value: class MockHTMLElement {
    scrollIntoView = jest.fn();
    focus = jest.fn();
  }
});
```

---

### **4. User Interaction Testing (Prevents 25% of failures)**

#### **A. Efficient User Events**
```typescript
// CRITICAL: Use appropriate interaction methods
// ‚ùå SLOW: Character-by-character typing for large content
await user.type(input, longText); // 4000ms+

// ‚úÖ FAST: Direct value setting for large content
fireEvent.change(input, { target: { value: longText } }); // 18ms

// ‚úÖ GOOD: Use userEvent for realistic interactions
await user.click(button);
await user.selectOptions(select, 'option1');
await user.upload(fileInput, file);
```

#### **B. Async State Testing**
```typescript
// CRITICAL: Test async state transitions properly
await user.click(submitButton);
expect(screen.getByRole('status')).toHaveTextContent('Loading...');

await waitFor(() => {
  expect(screen.queryByRole('status')).not.toBeInTheDocument();
});
expect(screen.getByText('Success!')).toBeInTheDocument();
```

---

### **5. CSS & Styling Testing (Prevents 20% of failures)**

#### **A. CSS Class Validation**
```typescript
// CRITICAL: Validate cn() utility usage
// ‚ùå BAD: Object syntax in cn() causes [object Object]
cn('base-class', { 'conditional-class': condition })

// ‚úÖ GOOD: Use logical operators
cn('base-class', condition && 'conditional-class')

// REQUIRED: Test actual CSS classes, not assumptions
expect(button).toHaveClass('btn-primary'); // Use design system classes
expect(button).not.toHaveClass('[object Object]'); // Prevent cn() bugs
```

#### **B. Design System Integration Testing**
```typescript
// REQUIRED: Test semantic color usage
expect(errorElement).toHaveClass('text-status-error'); // Not 'text-red-500'
expect(button).toHaveClass('btn-primary'); // Not custom Tailwind combinations
```

---

### **6. Form & Input Testing Patterns**

#### **A. Controlled Component Testing**
```typescript
// REQUIRED: Test controlled component behavior
const ControlledWrapper = () => {
  const [value, setValue] = useState('');
  return <Component value={value} onChange={setValue} />;
};

it('handles controlled input changes', async () => {
  render(<ControlledWrapper />);
  const input = screen.getByRole('textbox');
  
  await user.type(input, 'test value');
  expect(input).toHaveValue('test value');
});
```

#### **B. Form Validation Testing**
```typescript
// CRITICAL: Test validation states
it('shows validation errors', async () => {
  render(<FormComponent />);
  const input = screen.getByRole('textbox');
  const submitButton = screen.getByRole('button', { name: /submit/i });
  
  await user.click(submitButton);
  expect(screen.getByRole('alert')).toHaveTextContent('Field is required');
  expect(input).toHaveAttribute('aria-invalid', 'true');
});
```

---

### **7. Performance-Conscious Testing (Prevents 10% of failures)**

#### **A. Efficient Test Patterns**
```typescript
// CRITICAL: Use efficient assertions
// ‚ùå SLOW: Exact string matching for dynamic content
expect(timer).toBe('00:01.23'); // Breaks with timing variations

// ‚úÖ FAST: Flexible pattern matching
expect(timer).toMatch(/00:01\.[2-3]\d/); // Allows for timing variations

// ‚úÖ GOOD: Test presence, not exact content
expect(screen.getByText(/loading/i)).toBeInTheDocument();
```

#### **B. Skip Complex Integration Tests**
```typescript
// CRITICAL: Skip complex external API tests in unit tests
it.skip('complex Google Places integration', () => {
  // REASON: Works in production, requires extensive mocking
  // TEST IN: E2E tests or integration test suite
});

// ‚úÖ GOOD: Mock external dependencies
jest.mock('@/lib/external-api', () => ({
  fetchData: jest.fn(() => Promise.resolve(mockData))
}));
```

---

### **8. Test File Structure & Organization**

#### **A. Standard Test File Template (REQUIRED for new components)**
```typescript
/**
 * @fileoverview Tests for ComponentName
 * Following boombox-11.0 testing standards (97‚Üí0 failure learnings)
 */
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';
import { testAccessibility } from '@/tests/utils/accessibility';
import ComponentName from '@/components/path/ComponentName';

expect.extend(toHaveNoViolations);

// CRITICAL: Verify import/export patterns before mocking
// Check: grep -n "export" src/components/path/DependencyComponent.tsx

// Mock dependencies with correct patterns
jest.mock('@/components/dependency/Component', () => ({
  Component: function MockComponent(props: any) {
    return <div data-testid="mock-component" {...props} />;
  }
}));

// Mock Next.js dependencies if used
jest.mock('next/navigation', () => ({
  useRouter: jest.fn(() => ({
    push: jest.fn(),
    refresh: jest.fn()
  }))
}));

describe('ComponentName', () => {
  // REQUIRED: Test cleanup
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // REQUIRED: Basic rendering
  describe('Rendering', () => {
    it('renders without crashing', () => {
      render(<ComponentName />);
      expect(screen.getByRole('...')).toBeInTheDocument();
    });
  });

  // MANDATORY: Accessibility testing
  describe('Accessibility', () => {
    it('has no accessibility violations', async () => {
      const renderResult = render(<ComponentName />);
      await testAccessibility(renderResult);
    });

    it('maintains accessibility with error state', async () => {
      const renderResult = render(<ComponentName error="Test error" />);
      await testAccessibility(renderResult);
    });
  });

  // REQUIRED: User interaction testing
  describe('User Interactions', () => {
    it('handles user input correctly', async () => {
      const user = userEvent.setup();
      const mockOnChange = jest.fn();
      
      render(<ComponentName onChange={mockOnChange} />);
      const input = screen.getByRole('textbox');
      
      await user.type(input, 'test');
      expect(mockOnChange).toHaveBeenLastCalledWith('test');
    });
  });

  // Add component-specific test groups...
});
```

#### **B. Test Organization Patterns**
```typescript
// REQUIRED: Group tests logically
describe('ComponentName', () => {
  describe('Rendering', () => {
    // Basic rendering tests
  });

  describe('Accessibility', () => {
    // Accessibility tests (MANDATORY)
  });

  describe('User Interactions', () => {
    // Click, type, form submission tests
  });

  describe('State Management', () => {
    // Props, state changes, controlled components
  });

  describe('Error Handling', () => {
    // Error states, validation, edge cases
  });

  describe('Integration', () => {
    // Tests with other components, API calls
  });
});
```

---

### **9. Pre-Component-Completion Checklist (MANDATORY)**

**Before marking ANY component complete:**
- [ ] All tests pass locally (`npm test ComponentName`)
- [ ] Accessibility tests included and passing (MANDATORY)
- [ ] CSS classes tested match actual implementation  
- [ ] Async operations properly clear loading states
- [ ] Complex integrations either properly mocked or skipped
- [ ] Performance-conscious test patterns used
- [ ] Component architecture matches test expectations
- [ ] Import/export patterns verified and mocked correctly
- [ ] Test isolation and cleanup implemented
- [ ] User interactions tested with appropriate methods
- [ ] Error states and edge cases covered

---

### **10. Common Anti-Patterns to Avoid**

#### **A. Testing Implementation Details**
```typescript
// ‚ùå BAD: Testing internal state
expect(wrapper.state('isLoading')).toBe(true);

// ‚úÖ GOOD: Testing user-visible behavior
expect(screen.getByRole('status')).toBeInTheDocument();
```

#### **B. Brittle Selectors**
```typescript
// ‚ùå BAD: Fragile CSS selectors
expect(container.querySelector('.btn-primary-large')).toBeInTheDocument();

// ‚úÖ GOOD: Semantic queries
expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();
```

#### **C. Over-Mocking**
```typescript
// ‚ùå BAD: Mocking everything
jest.mock('@/lib/utils/formatDate');
jest.mock('@/lib/utils/formatCurrency');

// ‚úÖ GOOD: Mock only external dependencies
jest.mock('@/lib/api/external-service');
// Let utility functions run (they're pure and fast)
```

---

### **11. Testing Utilities & Helpers**

#### **A. Use Centralized Test Utilities**
```typescript
// REQUIRED: Use existing test utilities
import { testAccessibility } from '@/tests/utils/accessibility';
import { render } from '@/tests/utils/AddStorageTestWrapper'; // For complex components
```

#### **B. Create Reusable Test Helpers**
```typescript
// GOOD: Create helpers for common patterns
const renderWithUser = (component: React.ReactElement) => {
  const user = userEvent.setup();
  const renderResult = render(component);
  return { user, ...renderResult };
};

const expectAccessibleButton = async (button: HTMLElement) => {
  expect(button).toHaveAttribute('type');
  expect(button).not.toHaveAttribute('aria-disabled', 'true');
  // Add more accessibility checks
};
```

---

### **12. Test Performance & Maintenance**

#### **A. Test Execution Speed**
- Use `fireEvent` for large text input instead of `userEvent.type()`
- Mock heavy external dependencies
- Use `it.skip()` for complex integration tests that belong in E2E
- Prefer `screen.getByRole()` over complex DOM queries

#### **B. Test Maintainability**
- Test user behavior, not implementation details
- Use semantic queries (`getByRole`, `getByLabelText`)
- Group related tests in `describe` blocks
- Add descriptive test names that explain the expected behavior
- Use test utilities for common patterns

This comprehensive testing strategy ensures that our tests are **resilient to refactoring**, **fast to execute**, and **maintainable long-term**. Following these patterns prevents the cascade of test failures we experienced and creates a robust testing foundation for the entire application.

### Error Prevention
- Don't break existing import paths without updating references
- Don't change component functionality during refactoring
- Don't mix components in app directory
- Always create index.ts files for clean imports

## Performance & Bundle Size
- Use Next.js Image component for all images
- Implement dynamic imports for heavy components
- Monitor bundle size during refactoring
- Maintain or improve performance from boombox-10.0

## Package Management
- Use `pnpm` for package management
- Upgrade to latest stable versions only if no functionality changes
- Maintain exact versions for Onfleet, Stripe, and other critical integrations
- Document any package changes in git commits

### Package Optimization Rules
- **Dependency Audit**: During SETUP_001, scan for unused dependencies using `depcheck` or manual analysis
- **Removal Process**: NEVER remove packages without explicit human approval
- **Protected Packages**: Always preserve Onfleet, Stripe, Prisma, NextAuth, Twilio, SendGrid packages
- **Flag for Review**: Create list of potentially unused packages with usage analysis for human decision
- **Documentation**: Document all package changes with rationale in git commits

## Reference Documentation

### API Integration Guides
- **Onfleet API**: `docs/external-api-docs/onfleet-api-context.md` - Complete integration patterns and best practices
- **REFACTOR_PRD.md**: Master plan with atomic tasks and dependencies
- **Reference Files**: `../reference_files/` - Original documentation and context

### Quick Commands
- `pnpm run build` - Build check
- `pnpm run lint` - Code standards check  
- `pnpm run dev` - Development server
- `prisma migrate dev` - Database migrations (NOT `prisma db push`)

This rule set ensures consistency and prevents common issues during the boombox-11.0 refactoring project. 